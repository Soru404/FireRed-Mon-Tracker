<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pokémon FireRed Tracker</title>
  <style>
    body { font-family: 'Segoe UI', Tahoma, sans-serif; background: #f0f0f5; margin: 20px; }
    .container { max-width: 1200px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    h1 { text-align: center; margin-bottom: 20px; color: #333; }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; margin-bottom: 10px; }
    thead th { background-color: #4CAF50; color: #fff; padding: 12px; position: sticky; top: 0; z-index: 2; }
    thead th[contenteditable] { color: #000; }
    tbody tr:nth-child(even) { background-color: #f9f9f9; }
    tbody tr:hover { background-color: #f1f1f1; }
    /* Always use light backgrounds */
    tbody tr:nth-child(odd) { background-color: #ffffff; }
    th, td { background-color: #ffffff; }
    th, td { border: 1px solid #ddd; text-align: center; padding: 8px; }
    td.location-cell { text-align: left; font-weight: 600; background-color: #fcfcfc; width: 200px; }
    th[contenteditable], td[contenteditable] { background: #eef; cursor: text; }
    #add-row-btn { padding: 8px 12px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
    #add-row-btn:hover { background-color: #45a049; }
    .dropdown { position: absolute; background: white; border: 1px solid #aaa; max-height: 350px; overflow-y: auto; z-index: 100; box-shadow: 0 2px 6px rgba(0,0,0,0.2); padding: 5px; min-width: 200px; }
    .dropdown input { width: 100%; padding: 4px; margin-bottom: 6px; box-sizing: border-box; }
    .dropdown-item { display: flex; align-items: center; padding: 4px; cursor: pointer; }
    .dropdown-item:hover { background: #eee; }
    .dropdown-item img { width: 32px; height: 32px; margin-right: 6px; }
    .selected-line { display: flex; justify-content: center; flex-wrap: wrap; gap: 4px; }
    .selected-line img { width: 24px; height: 24px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Pokémon FireRed Tracker</h1>
    <table id="tracker">
      <thead>
        <tr>
          <th>Location</th>
          <th>Name</th>
          <th contenteditable="true">Player 1</th>
          <th contenteditable="true">Player 2</th>
          <th contenteditable="true">Player 3</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <button id="add-row-btn">Add Row</button>
  </div>
  <script>
    const defaultLocations = [
      "Pallet Town","Viridian City","Pewter City","Cerulean City","Vermilion City","Lavender Town","Celadon City","Fuchsia City","Saffron City","Cinnabar Island",
      "Route 1","Route 2","Route 3","Route 4","Route 5","Route 6","Route 7","Route 8","Route 9","Route 10","Route 11","Route 12","Route 13","Route 14","Route 15","Route 16","Route 17","Route 18","Route 19","Route 20","Route 21","Route 22","Route 23","Route 24","Route 25",
      "Mt. Moon","Diglett's Cave","Rock Tunnel","Seafoam Islands","Victory Road"
    ];
    let allLines = [], availableLines = [];

    function createRow(location = '', name = '') {
      const isDefault = defaultLocations.includes(location);
      const locAttr = isDefault ? '' : ' contenteditable';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="location-cell"${locAttr}>${location}</td>
        <td contenteditable>${name}</td>
        <td class="cell" data-player="1"></td>
        <td class="cell" data-player="2"></td>
        <td class="cell" data-player="3"></td>
      `;
      tr.querySelectorAll('[contenteditable]').forEach(el => el.addEventListener('input', saveState));
      return tr;
    }

    async function fetchJSON(file) {
      try { const res = await fetch(file); return res.ok ? res.json() : null; } catch (e) { console.error(e); return null; }
    }

    async function loadState() {
      const tbody = document.querySelector('#tracker tbody');
      tbody.innerHTML = '';

      let state = null;
      try {
        const res = await fetch(`${RAW_URL}?t=${Date.now()}`, { cache: 'no-store' });
        const text = await res.text();
        console.log('RAW_URL response status:', res.status);
        console.log('RAW_URL response text:', text);
        if (res.ok) {
          try {
            state = JSON.parse(text);
          } catch (e) {
            console.error('Could not parse JSON from state.json:', e);
          }
        }
      } catch (e) {
        console.error('Failed to fetch state.json', e);
      }

      if (!state || !Array.isArray(state.rows)) {
        console.warn('No valid state found, using defaults.');
        defaultLocations.forEach(loc => tbody.appendChild(createRow(loc, '')));
        return;
      }

      // Players
      document.querySelectorAll('thead th[contenteditable]').forEach((th, i) => {
        if (state.players && state.players[i] != null) th.textContent = state.players[i];
      });

      // Rows
      state.rows.forEach(r => {
        const tr = createRow(r.location, r.name);
        tbody.appendChild(tr);
        r.selections.forEach((sel, pIdx) => {
          if (sel) {
            const cell = tr.querySelector(`td[data-player="${pIdx+1}"]`);
            const wrapper = document.createElement('div');
            wrapper.className = 'selected-line';
            sel.forEach(poke => {
              const img = document.createElement('img');
              img.alt = poke.name;
              img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${poke.id}.png`;
              wrapper.appendChild(img);
            });
            cell.innerHTML = '';
            cell.appendChild(wrapper);
          }
        });
      });
    });
        });
      } else {
        defaultLocations.forEach(loc => document.querySelector('#tracker tbody').appendChild(createRow(loc, '')));
      }
    }

    async function saveState() {
      const players = Array.from(document.querySelectorAll('thead th[contenteditable]')).map(th => th.textContent.trim());
      const rows = Array.from(document.querySelectorAll('#tracker tbody tr')).map(tr => {
        const location = tr.querySelector('.location-cell').textContent.trim();
        const name = tr.cells[1].textContent.trim();
        const selections = [1,2,3].map(p => {
          const wrapper = tr.querySelector(`td[data-player="${p}"] .selected-line`);
          return wrapper
            ? Array.from(wrapper.querySelectorAll('img')).map(img => ({ name: img.alt, id: Number(img.src.match(/\/(\d+)\.png$/)[1]) }))
            : null;
        });
        return { location, name, selections };
      });
      const state = { players, rows };
      await fetch('state.json', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(state)
      });
    }

    async function loadEvolutionLines() {
      const data = await fetchJSON('https://pokeapi.co/api/v2/evolution-chain?limit=10000');
      if (!data) return;
      const chains = await Promise.all(data.results.map(r => fetch(r.url).then(r => r.json())));
      chains.forEach(chain => {
        // build every evolution branch separately so regional forms count as distinct lines
        function traverse(node, path) {
          const parts = node.species.url.split('/').filter(Boolean);
          const id = Number(parts[parts.length - 1]); // species ID
          const newPath = [...path, { name: node.species.name, id }];
          if (node.evolves_to && node.evolves_to.length) {
            node.evolves_to.forEach(child => traverse(child, newPath));
          } else {
            allLines.push(newPath); // reached end branch
          }
        }
        traverse(chain.chain, []);
      });
      availableLines = [...allLines];
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await loadEvolutionLines();
      await loadState();
      document.getElementById('add-row-btn').addEventListener('click', async () => {
        const tr = createRow('', '');
        document.querySelector('#tracker tbody').appendChild(tr);
        await saveState();
      });
      document.addEventListener('click', e => {
        const cell = e.target.closest('.cell');
        if (cell) showDropdown(cell);
        else if (!e.target.closest('.dropdown')) closeDropdown();
      });
    });

    function showDropdown(cell) {
      closeDropdown();
      const rect = cell.getBoundingClientRect();
      const dd = document.createElement('div'); dd.className = 'dropdown';
      dd.style.top = rect.bottom + 'px'; dd.style.left = rect.left + 'px';
      const input = document.createElement('input');
      input.placeholder = 'Search Pokémon...';
      dd.appendChild(input);
      const list = document.createElement('div');
      dd.appendChild(list);
      function render(filter = '') {
        list.innerHTML = '';
        availableLines.forEach((line, i) => {
          const text = line.map(p => p.name).join(' → ').toLowerCase();
          if (!filter || text.includes(filter)) {
            const item = document.createElement('div'); item.className = 'dropdown-item';
            line.forEach(p => { const img = document.createElement('img'); img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${p.id}.png`; img.alt = p.name; item.appendChild(img); });
            const span = document.createElement('span');
            span.textContent = line.map(p => p.name).join(' → ');
            item.appendChild(span);
            item.onclick = async () => {
              const wrapper = document.createElement('div'); wrapper.className = 'selected-line';
              line.forEach(p => { const img = document.createElement('img'); img.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${p.id}.png`; img.alt = p.name; wrapper.appendChild(img); });
              cell.innerHTML = '';
              cell.appendChild(wrapper);
              availableLines.splice(i, 1);
              await saveState();
              closeDropdown();
            };
            list.appendChild(item);
          }
        });
      }
      input.oninput = () => render(input.value.trim().toLowerCase());
      render();
      document.body.appendChild(dd);
    }

    function closeDropdown() {
      const e = document.querySelector('.dropdown');
      if (e) e.remove();
    }
  </script>
</body>
</html>
